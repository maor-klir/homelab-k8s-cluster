apiVersion: helm.toolkit.fluxcd.io/v2
kind: HelmRelease
metadata:
  name: loki
  namespace: loki
spec:
  interval: 30m
  chart:
    spec:
      chart: loki
      version: "6.x"
      sourceRef:
        kind: HelmRepository
        name: grafana
        namespace: loki
      interval: 12h
  install:
    crds: Create
  upgrade:
    crds: CreateReplace
  driftDetection:
    mode: enabled
  values:
    loki:
      podLabels:
        "azure.workload.identity/use": "true" # Add this label to the Loki pods to enable workload identity
      schemaConfig:
        configs:
          - from: "2024-04-01"
            store: tsdb
            object_store: azure
            schema: v13
            index:
              prefix: loki_index_
              period: 24h
      storage:
        type: azure
        bucketNames:
          chunks: "chunks" # Your actual Azure Blob Storage container name (loki-azure-dev-chunks)
          ruler: "ruler" # Your actual Azure Blob Storage container name (loki-azure-dev-ruler)
          # admin: "admin-loki-devrel" # Your actual Azure Blob Storage container name (loki-azure-dev-admin)
        azure:
          accountName: "lokisak3sprod012026"
          useFederatedToken: true # Use federated token for authentication
      ingester:
        chunk_encoding: snappy
      pattern_ingester:
        enabled: true
      limits_config:
        allow_structured_metadata: true
        volume_enabled: true
        retention_period: 2160h # 90 days retention
      compactor:
        retention_enabled: true
        delete_request_store: azure
      ruler:
        enable_api: true
        alertmanager_url: http://prom:9093 # The URL of the Alertmanager to send alerts (Prometheus, Mimir, etc.)

      querier:
        max_concurrent: 4

    # Define the Azure workload identity
    serviceAccount:
      create: false
      name: workload-identity-sa

    deploymentMode: Distributed

    ingester:
      replicas: 3
      zoneAwareReplication:
        enabled: false

    querier:
      replicas: 3
      maxUnavailable: 2

    queryFrontend:
      replicas: 2
      maxUnavailable: 1

    queryScheduler:
      replicas: 2

    distributor:
      replicas: 3
      maxUnavailable: 2

    compactor:
      replicas: 1

    indexGateway:
      replicas: 2
      maxUnavailable: 1

    ruler:
      replicas: 1
      maxUnavailable: 1

    # This exposes the Loki gateway so it can be written to and queried externaly
    gateway:
      service:
        type: ClusterIP
      basicAuth:
        enabled: true
        existingSecret: loki-basic-auth

    # Since we are using basic auth, we need to pass the username and password to the canary
    lokiCanary:
      extraArgs:
        - -pass=$(LOKI_PASS)
        - -user=$(LOKI_USER)
      extraEnv:
        - name: LOKI_PASS
          valueFrom:
            secretKeyRef:
              name: canary-basic-auth
              key: password
        - name: LOKI_USER
          valueFrom:
            secretKeyRef:
              name: canary-basic-auth
              key: username

    # Enable minio for storage
    minio:
      enabled: false

    backend:
      replicas: 0
    read:
      replicas: 0
    write:
      replicas: 0

    singleBinary:
      replicas: 0

    # Reduce cache memory to fit cluster capacity
    chunksCache:
      enabled: true
      replicas: 1
      allocatedMemory: 512 # 512MB instead of default ~10GB
      resources:
        requests:
          cpu: 100m
          memory: 512Mi
        limits:
          cpu: 200m
          memory: 512Mi
